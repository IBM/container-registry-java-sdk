/*
 * (C) Copyright IBM Corp. 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.ibm.cloud.container_registry.vulnerability_advisor.v3;

import com.ibm.cloud.container_registry.vulnerability_advisor.v3.VulnerabilityAdvisor;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.AccountReportQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.AccountStatusQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.CreateExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.CreateExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.DeleteExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.DeleteExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ExemptHandlerOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.Exemption;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ExemptionDeletionInfo;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ExemptionScope;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ExemptionTypeInfo;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ExemptionsAccountDeleteHandlerOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.GetExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.GetExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ImageReportQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ImageStatusQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ListAccountExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ListBulkImageExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ListExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ListExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ListImageExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanReport;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanReportList;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanreportImageSummary;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanreportImageSummaryList;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanreportSummary;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanresultCVE;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanresultConfigurationIssue;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanresultPackageFixes;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.model.ScanresultSecurityNotice;
import com.ibm.cloud.container_registry.vulnerability_advisor.v3.utils.TestUtilities;
import com.ibm.cloud.sdk.core.http.Response;
import com.ibm.cloud.sdk.core.security.Authenticator;
import com.ibm.cloud.sdk.core.security.NoAuthAuthenticator;
import com.ibm.cloud.sdk.core.service.model.FileWithMetadata;
import com.ibm.cloud.sdk.core.util.EnvironmentUtils;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.testng.PowerMockTestCase;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import static org.testng.Assert.*;

/**
 * Unit test class for the VulnerabilityAdvisor service.
 */
@PrepareForTest({ EnvironmentUtils.class })
@PowerMockIgnore({"javax.net.ssl.*", "org.mockito.*"})
public class VulnerabilityAdvisorTest extends PowerMockTestCase {

  final HashMap<String, InputStream> mockStreamMap = TestUtilities.createMockStreamMap();
  final List<FileWithMetadata> mockListFileWithMetadata = TestUtilities.creatMockListFileWithMetadata();

  protected MockWebServer server;
  protected VulnerabilityAdvisor vulnerabilityAdvisorService;

  // Creates a mock set of environment variables that are returned by EnvironmentUtils.getenv().
  private Map<String, String> getTestProcessEnvironment() {
    Map<String, String> env = new HashMap<>();
    env.put("TESTSERVICE_AUTH_TYPE", "noAuth");
    return env;
  }

  public void constructClientService() throws Throwable {
    PowerMockito.spy(EnvironmentUtils.class);
    PowerMockito.when(EnvironmentUtils.getenv()).thenReturn(getTestProcessEnvironment());
    final String serviceName = "testService";
    // set mock values for global params
    String account = "testString";
    String acceptLanguage = "testString";

    vulnerabilityAdvisorService = VulnerabilityAdvisor.newInstance(account, serviceName);
    String url = server.url("/").toString();
    vulnerabilityAdvisorService.setServiceUrl(url);
    vulnerabilityAdvisorService.setAcceptLanguage(acceptLanguage);
  }

  /**
  * Negative Test - construct the service with a null authenticator.
  */
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testConstructorWithNullAuthenticator() throws Throwable {
    final String serviceName = "testService";
    // set mock values for global params
    String account = "testString";

    new VulnerabilityAdvisor(account, serviceName, null);
  }


  @Test
  public void testGetAccount() throws Throwable {
    constructClientService();
    assertEquals(vulnerabilityAdvisorService.getAccount(), "testString");
  }


  @Test
  public void testGetAcceptLanguage() throws Throwable {
    constructClientService();
    assertEquals(vulnerabilityAdvisorService.getAcceptLanguage(), "testString");
  }

  @Test
  public void testAccountReportQueryPathWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"assessments\": {\"mapKey\": {\"configuration_issues\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"exempt\": true, \"meta\": {\"mapKey\": \"inner\"}, \"type\": \"type\"}], \"id\": \"id\", \"scan_time\": 8, \"status\": \"status\", \"vulnerabilities\": [{\"cve_exempt\": false, \"cve_id\": \"cveId\", \"exempt_security_notice_count\": 25, \"exempt_status\": \"exemptStatus\", \"security_notice_count\": 19, \"security_notices\": [{\"notice\": \"notice\", \"notice_exempt\": true, \"notice_id\": \"noticeId\", \"summary\": \"summary\", \"vulnerable_packages\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"fix_version\": \"fixVersion\", \"installed_version\": \"installedVersion\", \"package_name\": \"packageName\"}]}], \"summary\": \"summary\", \"total_security_notice_count\": 24}]}}}";
    String accountReportQueryPathPath = "/va/api/v3/report/account";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the AccountReportQueryPathOptions model
    AccountReportQueryPathOptions accountReportQueryPathOptionsModel = new AccountReportQueryPathOptions.Builder()
    .repository("testString")
    .includeIbm("testString")
    .includePrivate("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<ScanReportList> response = vulnerabilityAdvisorService.accountReportQueryPath(accountReportQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanReportList responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    // Get query params
    assertEquals(query.get("repository"), "testString");
    assertEquals(query.get("includeIBM"), "testString");
    assertEquals(query.get("includePrivate"), "testString");
    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, accountReportQueryPathPath);
  }

  @Test
  public void testAccountStatusQueryPathWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"images\": [{\"configuration_issue_count\": 23, \"created_time\": 11, \"exempt_configuration_issue_count\": 29, \"exempt_issue_count\": 16, \"exempt_vulnerability_count\": 24, \"issue_count\": 10, \"name\": \"name\", \"scan_time\": 8, \"status\": \"status\", \"vulnerability_count\": 18}]}";
    String accountStatusQueryPathPath = "/va/api/v3/report/account/status";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the AccountStatusQueryPathOptions model
    AccountStatusQueryPathOptions accountStatusQueryPathOptionsModel = new AccountStatusQueryPathOptions.Builder()
    .repository("testString")
    .includeIbm("testString")
    .includePrivate("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<ScanreportImageSummaryList> response = vulnerabilityAdvisorService.accountStatusQueryPath(accountStatusQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanreportImageSummaryList responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    // Get query params
    assertEquals(query.get("repository"), "testString");
    assertEquals(query.get("includeIBM"), "testString");
    assertEquals(query.get("includePrivate"), "testString");
    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, accountStatusQueryPathPath);
  }

  @Test
  public void testImageReportQueryPathWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"configuration_issues\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"exempt\": true, \"meta\": {\"mapKey\": \"inner\"}, \"type\": \"type\"}], \"id\": \"id\", \"scan_time\": 8, \"status\": \"status\", \"vulnerabilities\": [{\"cve_exempt\": false, \"cve_id\": \"cveId\", \"exempt_security_notice_count\": 25, \"exempt_status\": \"exemptStatus\", \"security_notice_count\": 19, \"security_notices\": [{\"notice\": \"notice\", \"notice_exempt\": true, \"notice_id\": \"noticeId\", \"summary\": \"summary\", \"vulnerable_packages\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"fix_version\": \"fixVersion\", \"installed_version\": \"installedVersion\", \"package_name\": \"packageName\"}]}], \"summary\": \"summary\", \"total_security_notice_count\": 24}]}";
    String imageReportQueryPathPath = "/va/api/v3/report/image/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ImageReportQueryPathOptions model
    ImageReportQueryPathOptions imageReportQueryPathOptionsModel = new ImageReportQueryPathOptions.Builder()
    .name("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<ScanReport> response = vulnerabilityAdvisorService.imageReportQueryPath(imageReportQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanReport responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, imageReportQueryPathPath);
  }

  // Test the imageReportQueryPath operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testImageReportQueryPathNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.imageReportQueryPath(null).execute();
  }

  @Test
  public void testImageStatusQueryPathWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"configuration_issue_count\": 23, \"exempt_configuration_issue_count\": 29, \"exempt_issue_count\": 16, \"exempt_vulnerability_count\": 24, \"issue_count\": 10, \"scan_time\": 8, \"status\": \"status\", \"vulnerability_count\": 18}";
    String imageStatusQueryPathPath = "/va/api/v3/report/image/status/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ImageStatusQueryPathOptions model
    ImageStatusQueryPathOptions imageStatusQueryPathOptionsModel = new ImageStatusQueryPathOptions.Builder()
    .name("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<ScanreportSummary> response = vulnerabilityAdvisorService.imageStatusQueryPath(imageStatusQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanreportSummary responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, imageStatusQueryPathPath);
  }

  // Test the imageStatusQueryPath operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testImageStatusQueryPathNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.imageStatusQueryPath(null).execute();
  }

  @Test
  public void testListExemptionAccountWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listExemptionAccountPath = "/va/api/v3/exempt/image";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ListExemptionAccountOptions model
    ListExemptionAccountOptions listExemptionAccountOptionsModel = new ListExemptionAccountOptions();

    // Invoke operation with valid options model (positive test)
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listExemptionAccount(listExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listExemptionAccountPath);
  }

  @Test
  public void testGetExemptionAccountWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String getExemptionAccountPath = "/va/api/v3/exempt/image/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the GetExemptionAccountOptions model
    GetExemptionAccountOptions getExemptionAccountOptionsModel = new GetExemptionAccountOptions.Builder()
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Exemption> response = vulnerabilityAdvisorService.getExemptionAccount(getExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, getExemptionAccountPath);
  }

  // Test the getExemptionAccount operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testGetExemptionAccountNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.getExemptionAccount(null).execute();
  }

  @Test
  public void testCreateExemptionAccountWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String createExemptionAccountPath = "/va/api/v3/exempt/image/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(201)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the CreateExemptionAccountOptions model
    CreateExemptionAccountOptions createExemptionAccountOptionsModel = new CreateExemptionAccountOptions.Builder()
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Exemption> response = vulnerabilityAdvisorService.createExemptionAccount(createExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, createExemptionAccountPath);
  }

  // Test the createExemptionAccount operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testCreateExemptionAccountNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.createExemptionAccount(null).execute();
  }

  @Test
  public void testDeleteExemptionAccountWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "";
    String deleteExemptionAccountPath = "/va/api/v3/exempt/image/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the DeleteExemptionAccountOptions model
    DeleteExemptionAccountOptions deleteExemptionAccountOptionsModel = new DeleteExemptionAccountOptions.Builder()
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Void> response = vulnerabilityAdvisorService.deleteExemptionAccount(deleteExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Void responseObj = response.getResult();
    // Response does not have a return type. Check that the result is null.
    assertNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "DELETE");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, deleteExemptionAccountPath);
  }

  // Test the deleteExemptionAccount operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testDeleteExemptionAccountNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.deleteExemptionAccount(null).execute();
  }

  @Test
  public void testListExemptionResourceWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listExemptionResourcePath = "/va/api/v3/exempt/image/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ListExemptionResourceOptions model
    ListExemptionResourceOptions listExemptionResourceOptionsModel = new ListExemptionResourceOptions.Builder()
    .resource("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listExemptionResource(listExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listExemptionResourcePath);
  }

  // Test the listExemptionResource operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListExemptionResourceNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.listExemptionResource(null).execute();
  }

  @Test
  public void testGetExemptionResourceWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String getExemptionResourcePath = "/va/api/v3/exempt/image/testString/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the GetExemptionResourceOptions model
    GetExemptionResourceOptions getExemptionResourceOptionsModel = new GetExemptionResourceOptions.Builder()
    .resource("testString")
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Exemption> response = vulnerabilityAdvisorService.getExemptionResource(getExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, getExemptionResourcePath);
  }

  // Test the getExemptionResource operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testGetExemptionResourceNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.getExemptionResource(null).execute();
  }

  @Test
  public void testCreateExemptionResourceWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String createExemptionResourcePath = "/va/api/v3/exempt/image/testString/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(201)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the CreateExemptionResourceOptions model
    CreateExemptionResourceOptions createExemptionResourceOptionsModel = new CreateExemptionResourceOptions.Builder()
    .resource("testString")
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Exemption> response = vulnerabilityAdvisorService.createExemptionResource(createExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, createExemptionResourcePath);
  }

  // Test the createExemptionResource operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testCreateExemptionResourceNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.createExemptionResource(null).execute();
  }

  @Test
  public void testDeleteExemptionResourceWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "";
    String deleteExemptionResourcePath = "/va/api/v3/exempt/image/testString/issue/testString/testString";

    server.enqueue(new MockResponse()
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the DeleteExemptionResourceOptions model
    DeleteExemptionResourceOptions deleteExemptionResourceOptionsModel = new DeleteExemptionResourceOptions.Builder()
    .resource("testString")
    .issueType("testString")
    .issueId("testString")
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Void> response = vulnerabilityAdvisorService.deleteExemptionResource(deleteExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Void responseObj = response.getResult();
    // Response does not have a return type. Check that the result is null.
    assertNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "DELETE");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, deleteExemptionResourcePath);
  }

  // Test the deleteExemptionResource operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testDeleteExemptionResourceNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.deleteExemptionResource(null).execute();
  }

  @Test
  public void testExemptHandlerWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "[{\"display_name\": \"displayName\", \"identifier\": \"identifier\", \"translationKey\": \"translationKey\", \"validation_regex\": \"validationRegex\"}]";
    String exemptHandlerPath = "/va/api/v3/exempt/types";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ExemptHandlerOptions model
    ExemptHandlerOptions exemptHandlerOptionsModel = new ExemptHandlerOptions();

    // Invoke operation with valid options model (positive test)
    Response<List<ExemptionTypeInfo>> response = vulnerabilityAdvisorService.exemptHandler(exemptHandlerOptionsModel).execute();
    assertNotNull(response);
    List<ExemptionTypeInfo> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, exemptHandlerPath);
  }

  @Test
  public void testListAccountExemptionsWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listAccountExemptionsPath = "/va/api/v3/exemptions/account";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ListAccountExemptionsOptions model
    ListAccountExemptionsOptions listAccountExemptionsOptionsModel = new ListAccountExemptionsOptions();

    // Invoke operation with valid options model (positive test)
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listAccountExemptions(listAccountExemptionsOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listAccountExemptionsPath);
  }

  @Test
  public void testExemptionsAccountDeleteHandlerWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"number_of_exemptions_deleted\": 25}";
    String exemptionsAccountDeleteHandlerPath = "/va/api/v3/exemptions/deleteAll";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ExemptionsAccountDeleteHandlerOptions model
    ExemptionsAccountDeleteHandlerOptions exemptionsAccountDeleteHandlerOptionsModel = new ExemptionsAccountDeleteHandlerOptions();

    // Invoke operation with valid options model (positive test)
    Response<ExemptionDeletionInfo> response = vulnerabilityAdvisorService.exemptionsAccountDeleteHandler(exemptionsAccountDeleteHandlerOptionsModel).execute();
    assertNotNull(response);
    ExemptionDeletionInfo responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, exemptionsAccountDeleteHandlerPath);
  }

  @Test
  public void testListImageExemptionsWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listImageExemptionsPath = "/va/api/v3/exemptions/image/testString";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ListImageExemptionsOptions model
    ListImageExemptionsOptions listImageExemptionsOptionsModel = new ListImageExemptionsOptions.Builder()
    .resource("testString")
    .includeScope(true)
    .build();

    // Invoke operation with valid options model (positive test)
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listImageExemptions(listImageExemptionsOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    // Get query params
    assertEquals(Boolean.valueOf(query.get("includeScope")), Boolean.valueOf(true));
    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listImageExemptionsPath);
  }

  // Test the listImageExemptions operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListImageExemptionsNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.listImageExemptions(null).execute();
  }

  @Test
  public void testListBulkImageExemptionsWOptions() throws Throwable {
    // Schedule some responses.
    String mockResponseBody = "{\"mapKey\": [{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]}";
    String listBulkImageExemptionsPath = "/va/api/v3/exemptions/images";

    server.enqueue(new MockResponse()
    .setHeader("Content-type", "application/json")
    .setResponseCode(200)
    .setBody(mockResponseBody));

    constructClientService();

    // Construct an instance of the ListBulkImageExemptionsOptions model
    ListBulkImageExemptionsOptions listBulkImageExemptionsOptionsModel = new ListBulkImageExemptionsOptions.Builder()
    .body(new java.util.ArrayList<String>(java.util.Arrays.asList("us.icr.io/birds/woodpecker:green", "us.icr.io/birds/grebe:crested")))
    .build();

    // Invoke operation with valid options model (positive test)
    Response<Map<String, List<Exemption>>> response = vulnerabilityAdvisorService.listBulkImageExemptions(listBulkImageExemptionsOptionsModel).execute();
    assertNotNull(response);
    Map<String, List<Exemption>> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    assertEquals(request.getHeader("Account"), "testString");

    // Check query
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);

    // Check request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listBulkImageExemptionsPath);
  }

  // Test the listBulkImageExemptions operation with null options model parameter
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListBulkImageExemptionsNoOptions() throws Throwable {
    // construct the service
    constructClientService();

    server.enqueue(new MockResponse());

    // Invoke operation with null options model (negative test)
    vulnerabilityAdvisorService.listBulkImageExemptions(null).execute();
  }

  /** Initialize the server */
  @BeforeMethod
  public void setUpMockServer() {
    try {
        server = new MockWebServer();
        // register handler
        server.start();
        }
    catch (IOException err) {
        fail("Failed to instantiate mock web server");
    }
  }

  @AfterMethod
  public void tearDownMockServer() throws IOException {
    server.shutdown();
    vulnerabilityAdvisorService = null;
  }
}