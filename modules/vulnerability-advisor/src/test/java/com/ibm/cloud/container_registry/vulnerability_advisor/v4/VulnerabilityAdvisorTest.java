/*
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.ibm.cloud.container_registry.vulnerability_advisor.v4;

import com.ibm.cloud.container_registry.vulnerability_advisor.v4.VulnerabilityAdvisor;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.AccountReportQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.AccountStatusQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.CreateExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.CreateExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.DeleteExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.DeleteExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ExemptHandlerOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.Exemption;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ExemptionDeletionInfo;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ExemptionScope;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ExemptionTypeInfo;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ExemptionsAccountDeleteHandlerOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.GetExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.GetExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ImageReportQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ImageStatusQueryPathOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ListAccountExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ListBulkImageExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ListExemptionAccountOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ListExemptionResourceOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ListImageExemptionsOptions;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanReport;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanReportList;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanReportOsDistribution;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanreportImageSummary;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanreportImageSummaryList;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanreportSummary;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanresultCVE;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanresultConfigurationIssue;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanresultPackageFixes;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.model.ScanresultSecurityNotice;
import com.ibm.cloud.container_registry.vulnerability_advisor.v4.utils.TestUtilities;
import com.ibm.cloud.sdk.core.http.Response;
import com.ibm.cloud.sdk.core.security.Authenticator;
import com.ibm.cloud.sdk.core.security.NoAuthAuthenticator;
import com.ibm.cloud.sdk.core.service.model.FileWithMetadata;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import static org.testng.Assert.*;

/**
 * Unit test class for the VulnerabilityAdvisor service.
 */
public class VulnerabilityAdvisorTest {

  final HashMap<String, InputStream> mockStreamMap = TestUtilities.createMockStreamMap();
  final List<FileWithMetadata> mockListFileWithMetadata = TestUtilities.creatMockListFileWithMetadata();

  protected MockWebServer server;
  protected VulnerabilityAdvisor vulnerabilityAdvisorService;

  // Construct the service with a null authenticator (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testConstructorWithNullAuthenticator() throws Throwable {
    final String serviceName = "testService";
    String account = "testString";
    new VulnerabilityAdvisor(account, serviceName, null);
  }

  // Test the getServiceUrlForRegion() method
  @Test
  public void testGetServiceUrlForRegion() throws Throwable {
    assertNull(VulnerabilityAdvisor.getServiceUrlForRegion("INVALID_REGION"));
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("global"), "https://icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("us-south"), "https://us.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("uk-south"), "https://uk.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("eu-gb"), "https://uk.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("eu-central"), "https://de.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("eu-de"), "https://de.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("ap-north"), "https://jp.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("jp-tok"), "https://jp.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("ap-south"), "https://au.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("au-syd"), "https://au.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("jp-osa"), "https://jp2.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("ca-tor"), "https://ca.icr.io");
    assertEquals(VulnerabilityAdvisor.getServiceUrlForRegion("br-sao"), "https://br.icr.io");
  }


  // Test the getter for the acceptLanguage global parameter
  @Test
  public void testGetAcceptLanguage() throws Throwable {
    assertEquals(vulnerabilityAdvisorService.getAcceptLanguage(), "testString");
  }


  // Test the getter for the account global parameter
  @Test
  public void testGetAccount() throws Throwable {
    assertEquals(vulnerabilityAdvisorService.getAccount(), "testString");
  }

  // Test the accountReportQueryPath operation with a valid options model parameter
  @Test
  public void testAccountReportQueryPathWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"assessments\": {\"mapKey\": {\"configuration_issues\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"exempt\": true, \"meta\": {\"mapKey\": \"inner\"}, \"type\": \"type\"}], \"id\": \"id\", \"os_distribution\": {\"distribution_id\": \"debian\", \"version_id\": \"11\", \"version_code_name\": \"bullseye\"}, \"scan_time\": 8, \"status\": \"status\", \"vulnerabilities\": [{\"cve_exempt\": false, \"cve_id\": \"cveId\", \"exempt_security_notice_count\": 25, \"exempt_status\": \"exemptStatus\", \"security_notice_count\": 19, \"security_notices\": [{\"notice\": \"notice\", \"notice_exempt\": true, \"notice_id\": \"noticeId\", \"summary\": \"summary\", \"vulnerable_packages\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"fix_version\": \"fixVersion\", \"installed_version\": \"installedVersion\", \"package_name\": \"packageName\"}]}], \"summary\": \"summary\", \"total_security_notice_count\": 24}]}}}";
    String accountReportQueryPathPath = "/va/api/v4/report/account";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the AccountReportQueryPathOptions model
    AccountReportQueryPathOptions accountReportQueryPathOptionsModel = new AccountReportQueryPathOptions.Builder()
      .repository("testString")
      .includeIbm("testString")
      .includePrivate("testString")
      .build();

    // Invoke accountReportQueryPath() with a valid options model and verify the result
    Response<ScanReportList> response = vulnerabilityAdvisorService.accountReportQueryPath(accountReportQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanReportList responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, accountReportQueryPathPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify query params
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    assertEquals(query.get("repository"), "testString");
    assertEquals(query.get("includeIBM"), "testString");
    assertEquals(query.get("includePrivate"), "testString");
  }

  // Test the accountReportQueryPath operation with and without retries enabled
  @Test
  public void testAccountReportQueryPathWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testAccountReportQueryPathWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testAccountReportQueryPathWOptions();
  }

  // Test the accountStatusQueryPath operation with a valid options model parameter
  @Test
  public void testAccountStatusQueryPathWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"images\": [{\"configuration_issue_count\": 23, \"created_time\": 11, \"exempt_configuration_issue_count\": 29, \"exempt_issue_count\": 16, \"exempt_vulnerability_count\": 24, \"issue_count\": 10, \"name\": \"name\", \"scan_time\": 8, \"status\": \"status\", \"vulnerability_count\": 18}]}";
    String accountStatusQueryPathPath = "/va/api/v4/report/account/status";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the AccountStatusQueryPathOptions model
    AccountStatusQueryPathOptions accountStatusQueryPathOptionsModel = new AccountStatusQueryPathOptions.Builder()
      .repository("testString")
      .includeIbm("testString")
      .includePrivate("testString")
      .build();

    // Invoke accountStatusQueryPath() with a valid options model and verify the result
    Response<ScanreportImageSummaryList> response = vulnerabilityAdvisorService.accountStatusQueryPath(accountStatusQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanreportImageSummaryList responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, accountStatusQueryPathPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify query params
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    assertEquals(query.get("repository"), "testString");
    assertEquals(query.get("includeIBM"), "testString");
    assertEquals(query.get("includePrivate"), "testString");
  }

  // Test the accountStatusQueryPath operation with and without retries enabled
  @Test
  public void testAccountStatusQueryPathWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testAccountStatusQueryPathWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testAccountStatusQueryPathWOptions();
  }

  // Test the imageReportQueryPath operation with a valid options model parameter
  @Test
  public void testImageReportQueryPathWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"configuration_issues\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"exempt\": true, \"meta\": {\"mapKey\": \"inner\"}, \"type\": \"type\"}], \"id\": \"id\", \"os_distribution\": {\"distribution_id\": \"debian\", \"version_id\": \"11\", \"version_code_name\": \"bullseye\"}, \"scan_time\": 8, \"status\": \"status\", \"vulnerabilities\": [{\"cve_exempt\": false, \"cve_id\": \"cveId\", \"exempt_security_notice_count\": 25, \"exempt_status\": \"exemptStatus\", \"security_notice_count\": 19, \"security_notices\": [{\"notice\": \"notice\", \"notice_exempt\": true, \"notice_id\": \"noticeId\", \"summary\": \"summary\", \"vulnerable_packages\": [{\"corrective_action\": \"correctiveAction\", \"description\": \"description\", \"fix_version\": \"fixVersion\", \"installed_version\": \"installedVersion\", \"package_name\": \"packageName\"}]}], \"summary\": \"summary\", \"total_security_notice_count\": 24}]}";
    String imageReportQueryPathPath = "/va/api/v4/report/image/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ImageReportQueryPathOptions model
    ImageReportQueryPathOptions imageReportQueryPathOptionsModel = new ImageReportQueryPathOptions.Builder()
      .name("testString")
      .build();

    // Invoke imageReportQueryPath() with a valid options model and verify the result
    Response<ScanReport> response = vulnerabilityAdvisorService.imageReportQueryPath(imageReportQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanReport responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, imageReportQueryPathPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the imageReportQueryPath operation with and without retries enabled
  @Test
  public void testImageReportQueryPathWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testImageReportQueryPathWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testImageReportQueryPathWOptions();
  }

  // Test the imageReportQueryPath operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testImageReportQueryPathNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.imageReportQueryPath(null).execute();
  }

  // Test the imageStatusQueryPath operation with a valid options model parameter
  @Test
  public void testImageStatusQueryPathWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"configuration_issue_count\": 23, \"exempt_configuration_issue_count\": 29, \"exempt_issue_count\": 16, \"exempt_vulnerability_count\": 24, \"issue_count\": 10, \"scan_time\": 8, \"status\": \"status\", \"vulnerability_count\": 18}";
    String imageStatusQueryPathPath = "/va/api/v4/report/image/status/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ImageStatusQueryPathOptions model
    ImageStatusQueryPathOptions imageStatusQueryPathOptionsModel = new ImageStatusQueryPathOptions.Builder()
      .name("testString")
      .build();

    // Invoke imageStatusQueryPath() with a valid options model and verify the result
    Response<ScanreportSummary> response = vulnerabilityAdvisorService.imageStatusQueryPath(imageStatusQueryPathOptionsModel).execute();
    assertNotNull(response);
    ScanreportSummary responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, imageStatusQueryPathPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the imageStatusQueryPath operation with and without retries enabled
  @Test
  public void testImageStatusQueryPathWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testImageStatusQueryPathWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testImageStatusQueryPathWOptions();
  }

  // Test the imageStatusQueryPath operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testImageStatusQueryPathNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.imageStatusQueryPath(null).execute();
  }

  // Test the listExemptionAccount operation with a valid options model parameter
  @Test
  public void testListExemptionAccountWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listExemptionAccountPath = "/va/api/v4/exempt/image";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ListExemptionAccountOptions model
    ListExemptionAccountOptions listExemptionAccountOptionsModel = new ListExemptionAccountOptions();

    // Invoke listExemptionAccount() with a valid options model and verify the result
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listExemptionAccount(listExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listExemptionAccountPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the listExemptionAccount operation with and without retries enabled
  @Test
  public void testListExemptionAccountWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testListExemptionAccountWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testListExemptionAccountWOptions();
  }

  // Test the getExemptionAccount operation with a valid options model parameter
  @Test
  public void testGetExemptionAccountWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String getExemptionAccountPath = "/va/api/v4/exempt/image/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the GetExemptionAccountOptions model
    GetExemptionAccountOptions getExemptionAccountOptionsModel = new GetExemptionAccountOptions.Builder()
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke getExemptionAccount() with a valid options model and verify the result
    Response<Exemption> response = vulnerabilityAdvisorService.getExemptionAccount(getExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, getExemptionAccountPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the getExemptionAccount operation with and without retries enabled
  @Test
  public void testGetExemptionAccountWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testGetExemptionAccountWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testGetExemptionAccountWOptions();
  }

  // Test the getExemptionAccount operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testGetExemptionAccountNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.getExemptionAccount(null).execute();
  }

  // Test the createExemptionAccount operation with a valid options model parameter
  @Test
  public void testCreateExemptionAccountWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String createExemptionAccountPath = "/va/api/v4/exempt/image/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(201)
      .setBody(mockResponseBody));

    // Construct an instance of the CreateExemptionAccountOptions model
    CreateExemptionAccountOptions createExemptionAccountOptionsModel = new CreateExemptionAccountOptions.Builder()
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke createExemptionAccount() with a valid options model and verify the result
    Response<Exemption> response = vulnerabilityAdvisorService.createExemptionAccount(createExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, createExemptionAccountPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the createExemptionAccount operation with and without retries enabled
  @Test
  public void testCreateExemptionAccountWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testCreateExemptionAccountWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testCreateExemptionAccountWOptions();
  }

  // Test the createExemptionAccount operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testCreateExemptionAccountNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.createExemptionAccount(null).execute();
  }

  // Test the deleteExemptionAccount operation with a valid options model parameter
  @Test
  public void testDeleteExemptionAccountWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "";
    String deleteExemptionAccountPath = "/va/api/v4/exempt/image/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the DeleteExemptionAccountOptions model
    DeleteExemptionAccountOptions deleteExemptionAccountOptionsModel = new DeleteExemptionAccountOptions.Builder()
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke deleteExemptionAccount() with a valid options model and verify the result
    Response<Void> response = vulnerabilityAdvisorService.deleteExemptionAccount(deleteExemptionAccountOptionsModel).execute();
    assertNotNull(response);
    Void responseObj = response.getResult();
    assertNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "DELETE");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, deleteExemptionAccountPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the deleteExemptionAccount operation with and without retries enabled
  @Test
  public void testDeleteExemptionAccountWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testDeleteExemptionAccountWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testDeleteExemptionAccountWOptions();
  }

  // Test the deleteExemptionAccount operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testDeleteExemptionAccountNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.deleteExemptionAccount(null).execute();
  }

  // Test the listExemptionResource operation with a valid options model parameter
  @Test
  public void testListExemptionResourceWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listExemptionResourcePath = "/va/api/v4/exempt/image/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ListExemptionResourceOptions model
    ListExemptionResourceOptions listExemptionResourceOptionsModel = new ListExemptionResourceOptions.Builder()
      .resource("testString")
      .build();

    // Invoke listExemptionResource() with a valid options model and verify the result
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listExemptionResource(listExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listExemptionResourcePath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the listExemptionResource operation with and without retries enabled
  @Test
  public void testListExemptionResourceWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testListExemptionResourceWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testListExemptionResourceWOptions();
  }

  // Test the listExemptionResource operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListExemptionResourceNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.listExemptionResource(null).execute();
  }

  // Test the getExemptionResource operation with a valid options model parameter
  @Test
  public void testGetExemptionResourceWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String getExemptionResourcePath = "/va/api/v4/exempt/image/testString/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the GetExemptionResourceOptions model
    GetExemptionResourceOptions getExemptionResourceOptionsModel = new GetExemptionResourceOptions.Builder()
      .resource("testString")
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke getExemptionResource() with a valid options model and verify the result
    Response<Exemption> response = vulnerabilityAdvisorService.getExemptionResource(getExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, getExemptionResourcePath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the getExemptionResource operation with and without retries enabled
  @Test
  public void testGetExemptionResourceWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testGetExemptionResourceWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testGetExemptionResourceWOptions();
  }

  // Test the getExemptionResource operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testGetExemptionResourceNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.getExemptionResource(null).execute();
  }

  // Test the createExemptionResource operation with a valid options model parameter
  @Test
  public void testCreateExemptionResourceWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}";
    String createExemptionResourcePath = "/va/api/v4/exempt/image/testString/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(201)
      .setBody(mockResponseBody));

    // Construct an instance of the CreateExemptionResourceOptions model
    CreateExemptionResourceOptions createExemptionResourceOptionsModel = new CreateExemptionResourceOptions.Builder()
      .resource("testString")
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke createExemptionResource() with a valid options model and verify the result
    Response<Exemption> response = vulnerabilityAdvisorService.createExemptionResource(createExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Exemption responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, createExemptionResourcePath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the createExemptionResource operation with and without retries enabled
  @Test
  public void testCreateExemptionResourceWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testCreateExemptionResourceWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testCreateExemptionResourceWOptions();
  }

  // Test the createExemptionResource operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testCreateExemptionResourceNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.createExemptionResource(null).execute();
  }

  // Test the deleteExemptionResource operation with a valid options model parameter
  @Test
  public void testDeleteExemptionResourceWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "";
    String deleteExemptionResourcePath = "/va/api/v4/exempt/image/testString/issue/testString/testString";
    server.enqueue(new MockResponse()
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the DeleteExemptionResourceOptions model
    DeleteExemptionResourceOptions deleteExemptionResourceOptionsModel = new DeleteExemptionResourceOptions.Builder()
      .resource("testString")
      .issueType("testString")
      .issueId("testString")
      .build();

    // Invoke deleteExemptionResource() with a valid options model and verify the result
    Response<Void> response = vulnerabilityAdvisorService.deleteExemptionResource(deleteExemptionResourceOptionsModel).execute();
    assertNotNull(response);
    Void responseObj = response.getResult();
    assertNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "DELETE");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, deleteExemptionResourcePath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the deleteExemptionResource operation with and without retries enabled
  @Test
  public void testDeleteExemptionResourceWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testDeleteExemptionResourceWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testDeleteExemptionResourceWOptions();
  }

  // Test the deleteExemptionResource operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testDeleteExemptionResourceNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.deleteExemptionResource(null).execute();
  }

  // Test the exemptHandler operation with a valid options model parameter
  @Test
  public void testExemptHandlerWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "[{\"display_name\": \"displayName\", \"identifier\": \"identifier\", \"translationKey\": \"translationKey\", \"validation_regex\": \"validationRegex\"}]";
    String exemptHandlerPath = "/va/api/v4/exempt/types";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ExemptHandlerOptions model
    ExemptHandlerOptions exemptHandlerOptionsModel = new ExemptHandlerOptions();

    // Invoke exemptHandler() with a valid options model and verify the result
    Response<List<ExemptionTypeInfo>> response = vulnerabilityAdvisorService.exemptHandler(exemptHandlerOptionsModel).execute();
    assertNotNull(response);
    List<ExemptionTypeInfo> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, exemptHandlerPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the exemptHandler operation with and without retries enabled
  @Test
  public void testExemptHandlerWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testExemptHandlerWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testExemptHandlerWOptions();
  }

  // Test the listAccountExemptions operation with a valid options model parameter
  @Test
  public void testListAccountExemptionsWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listAccountExemptionsPath = "/va/api/v4/exemptions/account";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ListAccountExemptionsOptions model
    ListAccountExemptionsOptions listAccountExemptionsOptionsModel = new ListAccountExemptionsOptions();

    // Invoke listAccountExemptions() with a valid options model and verify the result
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listAccountExemptions(listAccountExemptionsOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listAccountExemptionsPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the listAccountExemptions operation with and without retries enabled
  @Test
  public void testListAccountExemptionsWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testListAccountExemptionsWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testListAccountExemptionsWOptions();
  }

  // Test the exemptionsAccountDeleteHandler operation with a valid options model parameter
  @Test
  public void testExemptionsAccountDeleteHandlerWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"number_of_exemptions_deleted\": 25}";
    String exemptionsAccountDeleteHandlerPath = "/va/api/v4/exemptions/deleteAll";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ExemptionsAccountDeleteHandlerOptions model
    ExemptionsAccountDeleteHandlerOptions exemptionsAccountDeleteHandlerOptionsModel = new ExemptionsAccountDeleteHandlerOptions();

    // Invoke exemptionsAccountDeleteHandler() with a valid options model and verify the result
    Response<ExemptionDeletionInfo> response = vulnerabilityAdvisorService.exemptionsAccountDeleteHandler(exemptionsAccountDeleteHandlerOptionsModel).execute();
    assertNotNull(response);
    ExemptionDeletionInfo responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, exemptionsAccountDeleteHandlerPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the exemptionsAccountDeleteHandler operation with and without retries enabled
  @Test
  public void testExemptionsAccountDeleteHandlerWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testExemptionsAccountDeleteHandlerWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testExemptionsAccountDeleteHandlerWOptions();
  }

  // Test the listImageExemptions operation with a valid options model parameter
  @Test
  public void testListImageExemptionsWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "[{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]";
    String listImageExemptionsPath = "/va/api/v4/exemptions/image/testString";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ListImageExemptionsOptions model
    ListImageExemptionsOptions listImageExemptionsOptionsModel = new ListImageExemptionsOptions.Builder()
      .resource("testString")
      .includeScope(false)
      .build();

    // Invoke listImageExemptions() with a valid options model and verify the result
    Response<List<Exemption>> response = vulnerabilityAdvisorService.listImageExemptions(listImageExemptionsOptionsModel).execute();
    assertNotNull(response);
    List<Exemption> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "GET");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listImageExemptionsPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify query params
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNotNull(query);
    assertEquals(Boolean.valueOf(query.get("includeScope")), Boolean.valueOf(false));
  }

  // Test the listImageExemptions operation with and without retries enabled
  @Test
  public void testListImageExemptionsWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testListImageExemptionsWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testListImageExemptionsWOptions();
  }

  // Test the listImageExemptions operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListImageExemptionsNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.listImageExemptions(null).execute();
  }

  // Test the listBulkImageExemptions operation with a valid options model parameter
  @Test
  public void testListBulkImageExemptionsWOptions() throws Throwable {
    // Register a mock response
    String mockResponseBody = "{\"mapKey\": [{\"account_id\": \"accountId\", \"issue_id\": \"issueId\", \"issue_type\": \"issueType\", \"scope\": {\"scope_type\": \"scopeType\", \"namespace\": \"namespace\", \"repository\": \"repository\", \"tag\": \"tag\"}}]}";
    String listBulkImageExemptionsPath = "/va/api/v4/exemptions/images";
    server.enqueue(new MockResponse()
      .setHeader("Content-type", "application/json")
      .setResponseCode(200)
      .setBody(mockResponseBody));

    // Construct an instance of the ListBulkImageExemptionsOptions model
    ListBulkImageExemptionsOptions listBulkImageExemptionsOptionsModel = new ListBulkImageExemptionsOptions.Builder()
      .body(java.util.Arrays.asList("us.icr.io/birds/woodpecker:green", "us.icr.io/birds/grebe:crested"))
      .build();

    // Invoke listBulkImageExemptions() with a valid options model and verify the result
    Response<Map<String, List<Exemption>>> response = vulnerabilityAdvisorService.listBulkImageExemptions(listBulkImageExemptionsOptionsModel).execute();
    assertNotNull(response);
    Map<String, List<Exemption>> responseObj = response.getResult();
    assertNotNull(responseObj);

    // Verify the contents of the request sent to the mock server
    RecordedRequest request = server.takeRequest();
    assertNotNull(request);
    assertEquals(request.getMethod(), "POST");
    // Verify request path
    String parsedPath = TestUtilities.parseReqPath(request);
    assertEquals(parsedPath, listBulkImageExemptionsPath);
    // Verify header parameters
    assertEquals(request.getHeader("Account"), "testString");
    // Verify that there is no query string
    Map<String, String> query = TestUtilities.parseQueryString(request);
    assertNull(query);
  }

  // Test the listBulkImageExemptions operation with and without retries enabled
  @Test
  public void testListBulkImageExemptionsWRetries() throws Throwable {
    vulnerabilityAdvisorService.enableRetries(4, 30);
    testListBulkImageExemptionsWOptions();

    vulnerabilityAdvisorService.disableRetries();
    testListBulkImageExemptionsWOptions();
  }

  // Test the listBulkImageExemptions operation with a null options model (negative test)
  @Test(expectedExceptions = IllegalArgumentException.class)
  public void testListBulkImageExemptionsNoOptions() throws Throwable {
    server.enqueue(new MockResponse());
    vulnerabilityAdvisorService.listBulkImageExemptions(null).execute();
  }

  // Perform setup needed before each test method
  @BeforeMethod
  public void beforeEachTest() {
    // Start the mock server.
    try {
      server = new MockWebServer();
      server.start();
    } catch (IOException err) {
      fail("Failed to instantiate mock web server");
    }

    // Construct an instance of the service
    constructClientService();
  }

  // Perform tear down after each test method
  @AfterMethod
  public void afterEachTest() throws IOException {
    server.shutdown();
    vulnerabilityAdvisorService = null;
  }

  // Constructs an instance of the service to be used by the tests
  public void constructClientService() {
    System.setProperty("TESTSERVICE_AUTH_TYPE", "noAuth");
    final String serviceName = "testService";
    // set mock values for global params
    String acceptLanguage = "testString";
    String account = "testString";

    vulnerabilityAdvisorService = VulnerabilityAdvisor.newInstance(account, serviceName);
    String url = server.url("/").toString();
    vulnerabilityAdvisorService.setServiceUrl(url);
    // Set any optional global params
    vulnerabilityAdvisorService.setAcceptLanguage(acceptLanguage);
  }
}
